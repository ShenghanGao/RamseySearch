
#include <stdio.h>
#include <stdlib.h>
#include "list.h"
#include <stdbool.h>
#include "jrb.h"
/*
 * seach list to see if the cliques contains
 * edge(i, j). if a clique does not contain 
 * edge(i, j) and color is the same as the
 * clique's color, counter increments. The
 * counter is the number of new cliques that
 * will be generated if flip edge(i, j)
 */

int list_search_6(List *list, int *g, int g_size, int i, int j, int stop){
	int clique_size = list->clique_size;
	int counter = 0;
	JRB root = make_jrb();
	
	if( clique_size!=6){
		fprintf(stdout,"Wrong clique_size");
		return -1;
	}

	Clique *current = list -> front;
	while (current != NULL && counter <= stop) {
		int *nodeArray = current -> clique_node;		
		int key_array[7];
		bool inclique_i = false;
		bool inclique_j = false;
		int p;
		int out_index;

		for(p = 0; p < clique_size; p++){
			if(nodeArray[p] == i)
				inclique_i = p;
			if(nodeArray[p] == j)
				inclique_j = p;
		}


		int clique_color = current -> color;		
		if( inclique_j != inclique_i){
			if(inclique_j)
				out_index = i;
			else out_index = j;
			for( p = 0; p < clique_size; p++){
				if(g[nodeArray[p]*g_size+out_index]!=clique_color)
					break;
			}
			// get key array, an array of seven people 
			// sorted in ascending order. 
			int q = 0;
			bool out_index_added = false;
			for(p = 0; p < 7; p ++) {
				if(q >= 6 || (out_index < nodeArray[q] 
											&& !out_index_added)) {
					key_array[p] = out_index;
					out_index_added = true;
				}
				else key_array[p] = nodeArray[q ++];
			}

			if(p == clique_size) {
			
				int key, radix = 1; 
				MAKE_KEY(key_array, key, radix);
				if(!jrb_find_dbl(root, key)) {
					counter++;
					jrb_insert_dbl(root, current->key, new_jval_v(NULL));
				}
			}
	    current = current->next;
    }
    if(counter > stop)
        return(-1);
    return counter;
}



/*
 * seach list to see if the cliques contains
 * edge(i, j). if a clique contains edge(i, j) 
 * and color is the same as the clique's color, 
 * the counter increments. The counter is the
 * number of cliques has to be removed from the
 * original clique count
 */
int list_search_7(List *list, int i, int j){
	int clique_size = list->clique_size;
	int counter = 0;

	if( clique_size!=7){
		fprintf(stdout,"Wrong clique_size");
		return -1;
	}
	Clique *current = list -> front;
	while (current != NULL) {  
		int *nodeArray = current -> clique_node;
		bool inclique_i;
		bool inclique_j;
		int p;

		for(p = 0; p < clique_size; p++){
			if(nodeArray[p] == i)
				inclique_i=true;
			if(nodeArray[p]==j)
				inclique_j=true;
		}		
		if( inclique_j && inclique_i)
			counter++;
	    current = current->next;
	}
	return counter;
}

void list_add(List *list, Clique *clique){

	Clique *tail = list->back;
	if(tail != NULL){
		tail->next = clique;
	}
	else{
		list->front = clique;		
	}
	list->back = clique;
	list->length = list->length + 1;
	return;
}

void list_delete(List *list){
	Clique *toDelete = list->front;
	Clique *temp;
	
	while(toDelete!=NULL){	
		temp = toDelete;
		toDelete = toDelete -> next;
		free(temp);
	}
	free(list);
	return;
}

void print_list(List *list){
	Clique *toDelete = list -> front;
	fprintf(stdout," start print list \n ");
	int i;
	while(toDelete!=NULL){	
		int * array = toDelete-> clique_node;		
		for(i = 0; i<list->clique_size; i++){
			fprintf(stdout,"%d ", array[i]);
		}		
		toDelete = toDelete->next;	
	}	
	fprintf(stdout," end of print list \n ");
	return;
}


List* list_init(int clique_size){
	List* list =(List*) malloc(sizeof(List));
	list->front = NULL;
	list->back = NULL;
	list->clique_size = clique_size;
	list-> length = 0;
	return list;
}

Clique* clique_init_7(int color, int i, int j, 
											int k, int l, int m, 
											int n, int o){

	int *nodes; 
	Clique* clique = (Clique *) malloc(sizeof(Clique));
  nodes = (int *) malloc(7 * sizeof(int)); 
  nodes[0] = i; nodes[1] = j;
  nodes[2] = k; nodes[3] = l;
  nodes[4] = m; nodes[5] = n;
  nodes[6] = o;
	clique->clique_node = nodes;
	clique->color = color;
	clique->next = NULL;
	return clique;
}
// inline
Clique* clique_init_6(int color, int i, int j, 
											int k, int l, int m, int n) {
	int *nodes; 
	Clique* clique = (Clique *) malloc(sizeof(Clique));
  nodes = (int *) malloc(6 * sizeof(int)); 
  nodes[0] = i; nodes[1] = j;
  nodes[2] = k; nodes[3] = l;
  nodes[4] = m; nodes[5] = n;

	clique->clique_node = nodes;
	clique->color = color;
  clique->next = NULL;
	return clique;
}

// keys are big double that is 250 radix.  
// the maximum double is 1.7E+308, 250^7
// does not exceed the maximum

#define MAKE_KEY(key_array, key, radix) (\
	int it;												 \
	for(it = 0; it < 7; it ++) {   \
		key+= key_array[it] * radix; \
		radix *= 250;}							 

/*
int main( int argc, char *argv[])
{
	
	List *list = list_init(6);


    fprintf(stdout,"3333");
     Clique *clique1 = clique_init_6(0, 1,2,3,4,5,6);

     list_add(list,clique1);
     	
     print_list(list);
     Clique *clique2 = clique_init_6(0, 2,3,4,5,6,7);
     list_add(list,clique2);
     print_list(list);
    fprintf(stdout,"1111");
   //  list_delete(list);
   //  fprintf(stdout,"2222");
   //  print_list(list);

int *g =(int*)malloc(64*sizeof(int*));
     int counter = list_search_6(list, g, 8, 2,  8,  1);
     fprintf(stdout," counter = %d \n ",counter);
//int *g =(int*)malloc(64*sizeof(int*));
//int counter = list_search_6(list, g, 10, 10,  8,  100);
//fprintf(stdout," counter = %d \n ",counter);
    // Clique *clique3;
    // clique3 = (Clique*) malloc(sizeof(Clique));
    // clique_init_6(clique3, 0, 3,4,5,6,7,8);
    // list_add(list,clique3); 
    return(0); 
} */




















