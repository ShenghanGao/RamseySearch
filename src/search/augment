#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include "list.h"
#include "fifo.h"	/* for taboo list */
#include "time.h"
#include "clique_count.h"
#define MAXSIZE (541)
#define TABOOSIZE (500)
#define BIGCOUNT (500)

/*
 * example of very simple search for R(7, 7) counter 
 * examples starts with a small randomized graph and 
 * works its way up to successively larger graphs one 
 * at a time
 * uses a taboo list of size #TABOOSIZE# to hold and 
 * encoding of and edge (i, j) + clique_count
 */

int main(int argc, char *argv[])
{
	typedef enum {false, true} bool;
	int *g, *new_g;
	int gsize, count, i, j, rand_no, 
			best_count, best_i, best_j, try_count = 0,
			last_flip_i = -1, last_flip_j = -1, 
			last_flip_i_forward = -2,
			last_flip_j_forward = -2,
			mutation_col, n;
	void *taboo_list_forward, *taboo_list_backtrace;
	srand(time(NULL));
	bool backtrack_flag = false, break_flag = false, mutate_flag = false;
	long clique_6_min, clique_6_count;
//	List *cache_6, *cache_7;
	best_count = BIGCOUNT;
	ReadGraph("../../ce", &g, &gsize);
	while(gsize != 111) {
		PrintGraph(g, gsize);
		new_g = (int *) malloc((gsize + 1)* (gsize + 1) * sizeof(int));
		if(new_g == NULL) exit(1);
		// copy the old graph into the new graph leaving 
		// the last row and last column alone
		CopyGraph(g, gsize, new_g, gsize + 1);
		// throw away the old graph and make new one 
		free(g);
		g = new_g;
		// randomly assigned value for last column
		for(i = 0; i < gsize + 1; i ++) {
			rand_no = rand() % 100;
			if(rand_no > 50) {
				new_g[i * (gsize + 1) + gsize] = 1; // last column
				new_g[gsize * (gsize + 1) + i] = 1;	
			}
			else {
				new_g[i * (gsize + 1) + gsize] = 0; // last column
				new_g[gsize * (gsize + 1) + i] = 0;	
			}
		}
		gsize = gsize + 1;
	}
	return(0);
}

















