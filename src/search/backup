// we need to backtrace. let's start from the 
			// outmost edges, and work all the way 
			// to the inner edges. At the begining, we set the 
			// best_count to 100. Thus, if a flip generate 
			// count greater than the best_count, we discard it.	
			// We'll then remember the best flip and keep it 
			// next time around
			best_count = BIGCOUNT;	
			try_count = 0;
			//best_count = BIGCOUNT; // last_flip, actually we need to set best_count to zero and unflip the last edge 
			best_i = -3, best_j = -3;
			while(best_count != 0 && try_count != gsize * gsize / 2) {
//				cache_6 = list_init(6);
//				cache_7 = list_init(7);
				break_flag = false;
//				CliqueCountCreateCache(g, gsize, cache_6, cache_7);	
//				printf("cache_6 size: %d\n", cache_6->length);
				best_i = -2;
				for(j = gsize - 1; !break_flag && j >= 1; j --) {
					for(i = 0; i < j - 1; i ++) {
						if(i == last_flip_i && j == last_flip_j) continue;
			 			// flip it
						g[i * gsize + j] = 1 - g[i * gsize + j];
					//	count = CliqueCountUseCache(g, gsize, i, j, best_count, cache_6, cache_7);
						long clique_6_count;
						count = CliqueCountFast(g, gsize, best_count, &clique_6_count);
						// count is either -1 or not -1 and less than best_count
				//		if(!FIFOFindEdgeCount(taboo_list_forward, i, j, count)) {
							if(count >= 0 && count < best_count) {
								if(!FIFOFindEdgeCount(taboo_list_backtrace, i, j, count)) {
									best_count = count;
									best_i = i;
									best_j = j;
								//if(count == 0)  {
									g[i * gsize + j] = 1 - g[i * gsize + j];
									break_flag = true; 
									break;
								} else printf("Already in the backtrace taboo list!\n");
							} 							//printf("BACKTRACING size: %d, best_6_count: %d, best_count: %d, best edge: (%d,%d), new color: %d\n",
							// gsize, clique_6_min, best_count, best_i, best_j,
							// g[best_i * gsize + best_j]);
					/*		else if (count == best_count) {
								best_count = count;
								best_i = i;
								best_j = j;
							}*/

						}
						// flip it back
						g[i * gsize + j] = 1 - g[i * gsize + j]; 
					}
				}
				// it is possible here that if none of the edge is 
				// flipped. we may end up fliping the same edge back
				// and forth


				if(best_i == -2) {
					// introduce some muttation ^_^
					// random select a column
					mutation_col = rand() % gsize;
					j = mutation_col;
					printf("MUTATE!!!!!!!!!!!! col %d\n", j);
					for(i = 0; i < j - 1; i ++) {
						rand_no = rand() % 100;
						if(rand_no > 50) {
							g[i * (gsize + 1) + gsize] = 1; // last column
							g[gsize * (gsize + 1) + i] = 1;	
						} else {
							g[i * (gsize + 1) + gsize] = 0; // last column
							g[gsize * (gsize + 1) + i] = 0;	
						}
					}
					j = gsize - 1;
					for(i = 0; i < j - 1; i ++) {
						rand_no = rand() % 100;
						if(rand_no > 50) {
							g[i * (gsize + 1) + gsize] = 1; // last column
							g[gsize * (gsize + 1) + i] = 1;	
						} else {
							g[i * (gsize + 1) + gsize] = 0; // last column
							g[gsize * (gsize + 1) + i] = 0;	
						}
					}
					best_count = BIGCOUNT;
					mutate_flag = true;
					break;
				}

				// Since we set best_i and best_j to negative, we
				// may need to check here. Another possibility is 
				// that if no count better than the best count is 
				// found, we won't be able to change any of the edge
				// Here comes an dead lock. Thus, we need to allow 
				// degenerate. 
				printf("BACKTRACKING size: %d, best_count: %d,\
				best edge: (%d, %d), new color: %d\n",
							 gsize, best_count, best_i, best_j, 
							 g[best_i * gsize + best_j]); 
				// keep the best flip we saw there is a bug here. 
				g[best_i * gsize + best_j] = 1 - g[best_i * gsize + best_j];
				last_flip_i = best_i;
				last_flip_j = best_j;
		  	// taboo this graph configuration so that we 
				// don't visit it again
				//FIFOInsertEdgeCount(taboo_list_backtrace, best_i, best_j, count);
				FIFOInsertEdgeCount(taboo_list_forward, best_i, best_j, count);
				//list_delete(cache_6);
				//list_delete(cache_7);
				try_count ++;
			}
			/*if(best_count != 0) {
				printf("no best edge found, terminating\n");
				exit(1);
			} else backtrack_flag = false;*/









//				cache_6 = list_init(6);
//				cache_7 = list_init(7);
				break_flag = false;
//				CliqueCountCreateCache(g, gsize, cache_6, cache_7);	
//				printf("cache_6 size: %d\n", cache_6->length);
				best_i = -2;
				for(j = gsize - 1; !break_flag && j >= 1; j --) {
					for(i = 0; i < j - 1; i ++) {
						if(i == last_flip_i && j == last_flip_j) continue;
			 			// flip it
						g[i * gsize + j] = 1 - g[i * gsize + j];
					//	count = CliqueCountUseCache(g, gsize, i, j, best_count, cache_6, cache_7);
						long clique_6_count;
						count = CliqueCountFast(g, gsize, best_count, &clique_6_count);
						// count is either -1 or not -1 and less than best_count
				//		if(!FIFOFindEdgeCount(taboo_list_forward, i, j, count)) {
							if(count >= 0 && count < best_count) {
								if(!FIFOFindEdgeCount(taboo_list_backtrace, i, j, count)) {
									best_count = count;
									best_i = i;
									best_j = j;
								//if(count == 0)  {
									g[i * gsize + j] = 1 - g[i * gsize + j];
									break_flag = true; 
									break;
								} else printf("Already in the backtrace taboo list!\n");
							} 							//printf("BACKTRACING size: %d, best_6_count: %d, best_count: %d, best edge: (%d,%d), new color: %d\n",
							// gsize, clique_6_min, best_count, best_i, best_j,
							// g[best_i * gsize + best_j]);
					/*		else if (count == best_count) {
								best_count = count;
								best_i = i;
								best_j = j;
							}*/

						}
						// flip it back
						g[i * gsize + j] = 1 - g[i * gsize + j]; 
					}
				}












						if(i == last_flip_i && j == last_flip_j) continue;
			 			// flip it
						g[i * gsize + j] = 1 - g[i * gsize + j];
					//	count = CliqueCountUseCache(g, gsize, i, j, best_count, cache_6, cache_7);
						long clique_6_count;
						count = CliqueCountFast(g, gsize, best_count, &clique_6_count);
						// count is either -1 or not -1 and less than best_count
				//		if(!FIFOFindEdgeCount(taboo_list_forward, i, j, count)) {
							if(count >= 0 && count < best_count) {
								if(!FIFOFindEdgeCount(taboo_list_backtrace, i, j, count)) {
									best_count = count;
									best_i = i;
									best_j = j;
								//if(count == 0)  {
									g[i * gsize + j] = 1 - g[i * gsize + j];
									break_flag = true; 
									break;
								} else printf("Already in the backtrace taboo list!\n");
							} 							//printf("BACKTRACING size: %d, best_6_count: %d, best_count: %d, best edge: (%d,%d), new color: %d\n",
							// gsize, clique_6_min, best_count, best_i, best_j,
							// g[best_i * gsize + best_j]);
					/*		else if (count == best_count) {
								best_count = count;
								best_i = i;
								best_j = j;
							}*/

					
						// flip it back
						g[i * gsize + j] = 1 - g[i * gsize + j]; 
